---
layout: post
title: Елегантна робота з git
category: git
tags: git hacks
published: true
summary: Інтуітивно зрозумілий підхід внесення змін через git
---

# Трохи про значення команд #

git використовує три абстракції:

* `HEAD`, як вказівник на крайній "коміт", 
* індекс, як набір усієї інфи перед комітом
* файлове дерево, тут все просто.

### clone ###

`git clone` переносить все що було в чужому `HEAD` до робочої директорії

### add ###

`git add` перевіряє поточний стан робочої директорії та _перезаписує_ інформацію в індексі
(його ще називають *stage*)

### commit ###

`git commit` перевіряє поточний стан індексу, та записує цю інфу для довготривалого зберігання.
Власен це я звик називати комітом до репозиторію, хоч `git add` теж дещо на це схожий. Також `git commit`
оновлює `HEAD`, щоб той вказував на свіжо-записаний "коміт".

# Тож як з цим працювати #

Ці команди працють лише з двома абстракціями, тож коли видалено робочу директорію разом з
усіма файлами, але інформація ще збережана в індексі `git commit` спрокійно прокотить

### status ###

`git status` показує відмінність між робочою диретроією та інформцією в індексі червоним кольором,
зеленим показано різницю між останнім комітом (він же `HEAD`) та індексом. Саму інформацію в індексі можна глянути 
через `git ls-tree`. Як глянути різницю між `HEAD` та робочою директорією? *Ніяк*! Справжнім хакерам таке нафіг треба %)

### reset ###

Найцікавіше.

Є дві основні форми `git reset`:

1. `git reset [commit] [path]`
2. `git reset [commit]`

git reset це обернена операція до git commit. Ця команда бере дані з локальної БД git (за замовчуванням це `HEAD`) та перезаписує всю інформацію в індексі цими данними.

Отже git reset виконує три дії послідовно, а використовуючи параметри --soft --mixed --hard можна зупинити git reset в різні моменти в цій послідовності дій:

* `--soft` переносить лише вказівник `HEAD`, фактично це дія обернена до `git commit` 
    git reset --soft HEAD~
* `--mixed` це дія за замовженням, яка власне і перезаписує дані в індексі. Ще кажуть "unstage the changes". Це вже звородня для до `git add`.
* `--hard` йде ще на один крок далі па переносить інформацію з індесу на робочу директорію (все що втрачено в робочій директорії дійсно важко повернути, звідси й назва параметру *троло-ло-ло*). А тут жестяк - всеодно, що забути про редагування файлу, без збереження

# нахріна я це все писав? #

Я ніяк не можу запам'ятати як зібрати декілька комітив в одну купу, щоб не відсиланти на github коміти з дурнуватими повідомленнями типу "Bug fixes", або "Some minor changes". 

Барабанний дріб!

Арсене, зарубай ці дві стрічки собі на носі (а краще просто заBASHляй в `.profile`):
    git reset --soft HEAD~2
    git commit

або якщо тобі коли-небудь трапиться менеджер, який розумітиме красу простих структурованих комітів, кожен з яких розв'язує одну задачу чи закриває одну історію можна і повимахуватись:
    git reset HEAD~2
    git add -p
    git commit

Останні дві стрічки можна буде повторювати стільки скільи буде задач. Виглядатиму, курча, як мега-акуратний штрих.

### checkout ###

А тепер геть темна сторона. Можна ще бавитись із `git checkout` та  `git reset` поміж різними гілками проекту. Наприклад якщо є гілка develop і master можна напискати ттаке:
    git checkout develop # перейшли в гілку 'develop'
    git commit           # зробили новий коміт
    git reset master     # залишаючись в гілці 'develop' перенесли її HEAD на той же коміт де зараз знаходиться гілка master
    git checkout master  # перейшли в гілку 'master'

# Залишається декілька команд із слюсарно-водопровідної справи #

Ага, це мені гугл так підказав ;) Все це ще треба буде добряче вкурити, тож лише зазначу перелік з коротким описом команд

- `rev-parse` & `hash-object` - is soft of a "put" 
- `ls-tree` - inspects trees
- `ls-files` - inspects your index
- `read-tree` - pulls stuff into your index directly on the tree level
- `update-index` - pull stuff into your index on the file level
- `write-tree` - writes your index out as a new tree into a database
- `commit-tree` - write a commit object that points to that tree
- `update-ref` - cтворює нову гілку, updates a branch to point to that commit
- `symbolic-ref` - переносить HEAD, updates HEAD to point to that branch
- `wtfwiewtut` - whythefuckwouldieverwanttousethis
